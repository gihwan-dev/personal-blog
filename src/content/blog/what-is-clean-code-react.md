---
author: Gihwan-dev
pubDatetime: 2024-05-30T00:27:39.599Z
modDatetime: 2024-07-02T07:43:22.113Z
title: 리액트 클린코드에 대해서 고민해 보았다
slug: what-is-clean-code-react
featured: true
draft: false
tags:
  - development
  - architecture
  - cleancode
description: 최근 아키텍쳐를 구상하고 보기좋은 코드를 작성하는것에 대한 고민을 하면서 느낀점들을 정리해 봤습니다
---

클린코드를 작성하려면 어떤 것들을 생각해야할까? 라는 물음에서 시작해서 내가 생각하는 좋은 구성을 생각하고 정리해 봤습니다.

## Table of contents

## 변수 네이밍

- 명사
- is 또는 has로 시작

## 함수 네이밍

- 일반 함수: 동사로 시작
- 이벤트 핸들러: handle

## props에 대한 생각

props를 어떻게 다뤄야할까?

- props는 함수의 인자다.
- local state는 함수 내부에 선언된 **지역 변수**다.
- 전역 상태, 리액트 쿼리는 함수 내부에 선언된 **전역 변수**다.

## 상태 관리에 대한 생각

상태는 데이터다. 다만 변경시 사이드이펙트를 일으키는 전역 변수다. 상태는 다음의 값으로부터 얻어질 수 있다. `React Query`, `Zustand`, `Context API`, `useState` 이에 대해 정리해보자.

- 리액트 쿼리와 zustand는 훅이 아닌 데이터로 생각한다.
- 언제 Context API를 사용하고 전역 상태는 언제 사용할까?
  - Context API: 값이 자주 변경되지 않는 전역의 어떤 상태를 사용해야 할 경우. (theme provider 등)
  - 전역 상태 관리 라이브러리: 값이 자주 변경되는 어떤 상태를 사용해야 할 경우.
- dispatch 함수는 어느정도 역할까지 가능해야 할까?
  - 상태를 변경하는 로직만 수행한다. zustand의 store는 오로지 값으로만 사용하며 dispatch는 상태의 수정만 담당한다.
- zustand 스토어는 어느정도 단위여야 하나?
  - 하나의 스토어만 가지게 하라고 한다. 그런데 전역 상태가 많아지면 한 스토어가 너무 비대해지지 않나? => 도메인 단위로 스토어를 가진다.

## 컴포넌트에 대한 생각

- depth가 깊어지는 것에 대한 고민을 해야한다.
- children을 인자로 받는 컴포넌트는 함수를 인자로 받는 **고차 함수** 아닌가? 고차 함수를 사용하면 함수의 depth가 깊어지는 것을 해결할 수 있다.
- props는 있는게 좋다. 깊지만 않다면. 입력과 출력을 명확히 할 수 있어 추적에 용이하다.
- 컴포넌트도 계층 구조를 분리하고 추상화를 해야한다.

## 비즈니스 로직 처리하기

- 커스텀 훅
  - 비즈니스 로직을 수행하자. 커스텀훅은 오로지 컴포넌트에서만 호출될 수 있다. 비즈니스 로직 컨트롤러라 생각하자. 다양한 비즈니스 로직을 조합해 반환한다.
- 일반 함수
  - 비즈니스 로직과 관련된 일반 함수다. 유틸리티 함수의 조합이다.
- 유틸리티 함수
  - 가장 작은 단위의 일을 하는 함수다. 도메인과 관련된 유틸리티함수, 관련되지 않은 유틸리티 함수로 분리된다. 관련되지 않을 경우 공용 함수다. 이럴 경우 데이터를 단위로 함수를 분리할 수 있을것 같다. 관련 되었을 경우 도메인과 관련된 데이터 단위로 분리할 수 있다.

## 컴포넌트 계층 구조를 설계해 책임 분리하기

- 페이지 컴포넌트: 각 컴포넌트를 조합해 페이지를 구성한다. 모듈로 동작하며 어떤 로직도 포함하지 않는다.
- 컴포넌트
  - View 컴포넌트: UI를 그리고 이벤트를 발생시키는 역할을 한다. 이 컴포넌트 내부에 비즈니스 로직이 존재해서는 안된다. 이 컴포넌트는 이벤트를 발생시키고 변경된 상태에 따른 UI를 그리는 역할만을 담당한다.
    - 네이밍 커벤션: [도메인] + View를 붙인다. ex) LoginEmailInputView
  - 모듈 컴포넌트: View 컴포넌트를 적당한 단위로 묶어 필요한 값을 전달해준다. 커스텀 훅에서 처리된 비즈니스 로직의 결과 또는 수행 되어야 하는 이벤트 핸들러 등을 정의해서 View에 전달한다. 존재할 수 있고 존재하지 않을 수 있다. 어떤 컴포넌트가 정적인 `View`의 역할 이외에 다른 역할을 하지 않는다면 `View`면서 동시에 `모듈` 이다. (ex: Layout과 같은)
  - 프로바이더 컴포넌트: ContextAPI를 전달하는 컴포넌트. 페이지 컴포넌트에서 호출된다.
  - 페이지 컴포넌트: 각각의 컴포넌트들을 import해 하나의 페이지를 구성한다.

### 컨트롤러 컴포넌트에 의해 관리되는 View 컴포넌트는 어느정도까지의 도메인을 포함해야 하나?

적절한 기능을 도메인 단위 묶을 수 있지 않을까? 하는 생각이 든다. 로그인 폼을 생각해보자.

로그인 폼은 로그인 기능을 담당한다. 내부에는 다음과 같은 기능이 있을 수 있다.

- 이메일 입력 기능: 이메일 입력, 이메일 유효성 검증, 이메일 입력에 따른 View 처리
- 패스워드 입력 기능: ....
- 로그인 관련 입력 제출 기능: ...

등등이 있을거다. 이 각각의 입력과 관련된 컨트롤러를 만들 수 있다. 다만 이건 오버 엔지니어링이 아닌가? 하는 생각이 든다. 즉, 컨트롤러 컴포넌트는 유사한 기능의 View를 모아 각 View 컴포넌트가 필요한 값을 전달해 주는 역할을 한다. 기능 단위로 분리해 생각해보자. 계속해서 시도해보고 고민해보는게 스스로 정답을 찾을 수 있는 가장 빠른 길인 것 같다.

## 공용 컴포넌트 설계하기

작은 일을 할수록, 도메인에 묶이지 않을수록 재사용성이 높다. 굳이 도메인이 묶일 필요가 없는 컴포넌트 라면 공용 컴포넌트가 될 수 있다.

공용 컴포넌트는 어느정도로 작은일을 해야할까?

- 적절한 수준의 추상화가 필요하다. 작을수록 좋다면 input 태그를 그냥 쓰는게 좋지 않나?
- 무분별한 prop의 확장은 공통 컴포넌트의 가치를 떨어트린다. 만능 컴포넌트를 지양하자. 공통 컴포넌트의 목적은 개발시간 단축과 유지보수 간편화에 있다. prop이 너무 많으면 이를 다루는 로직도 많아지고 더 복잡한 컴포넌트가 된다. 사용하기도 어렵다. 매개변수가 수십개가 있는 함수를 생각해보자. 어떻게 사용하겠는가.

## 결론

최근 `귀에 쏙쏙 들어오는 함수형 프로그래밍` 이라는 책을 읽으면서 함수의 책임 분리와 계층적 설계 같은 것들에 대해 공부했다. 스스로 리액트 아키텍쳐에 대해 고민하고 정리해보니 이 컴포넌트의 설계도 결국 **책임의 분리** 가 목표인 것 같다. 각 컴포넌트, 훅 에 대해 책임을 잘 분리해서 사용하기 쉽고 기능 추가 수정이 쉬운 코드를 작성하자! 가 주 목표인 것 같다.

계속해서 적용하며 이 내용을 수정하고 보완할 예정이다.

### 2024.06.18 느낀점

오늘 이 패턴을 토대로 리팩토링을 진행 해봤다. 다만 잘못 생각한 부분이 있어 정리하고자 한다.

일단 모듈로 기능을 단위로 View 컴포넌트를 묶어내고자 했다. 다만 이게 프론트엔드에서 힘든 경우가 많다는 점이다. 이렇게 묶음의 단위에 기능만 있어서는 안된다. 레이아웃이나 디자인도 고려되어야 한다는게 문제였다. 예를들어보자. 로그인 페이지에 이메일 입력, 패스워드 입력, 제출 버튼이 있다.

기능적으로 묶으면 이메일과 패스워드 입력, 제출 버튼은 하나의 기능 바운더리에 들어갈 수 있다.

그런데 디자인적으로 묶었을 때 입력 두개는 묶일 수 있지만, 버튼은 아니었다. 결국 이를 해결하기 힘들었고 다시 고민하게 되었다. 그러다 `VAC` 패턴이라는걸 발견했다.

그래서 수정했다. `VAC` 패턴과 컴파운드 컴포넌트 패턴 그리고 아토믹 디자인을 적용해 보려 한다. 아토믹하게 디자인해 `VAC` 패턴을 적용하고 이들을 컴파운드 컴포넌트 패턴으로 위치 시킨다. 그러면 어느정도 레이아웃에 자유로우면서도 View 컴포넌트에서 비즈니스 로직을 처리하지 않고 Props 컴포넌트에서 커스텀 훅을 통해 내려줄 수 있다.

### 07.02 느낀점

리팩토링을 진행하며 이벤트 핸들러의 선언 위치와 소모 위치에 대한 고민을 하게 되었다.

이벤트 핸들러는 어디에 선언되어야 할까? 다음 두 패턴에 따라 진행되면 좋겠다는 생각이 들었다.

1. 상태를 중앙집중형으로 관리하는 패턴
2. 상태를 아토믹하게 관리하는 경우

#### 상태를 중앙 집중형으로 관리하는 경우

일단 먼저 해야할 이야기는 이벤트 핸들러는 컴포넌트 내부에서 반드시 드러내기로 했다는 점이다. 이벤트 핸들러는 이벤트가 호출되어 일어나는 일들에 대해 기술된 함수다. 일어나는 일들에 대한 내용을 반드시 드러날 필요가 있다고 생각했다. 이전에는 커스텀 훅에서 이벤트 핸들러를 전달하곤 했는데 이는 부적합한 방식이며 오히려 혼란을 야기한다고 생각했다. 너무 많은 이동이 필요하고 컴포넌트에서 한눈에 파악하기 어렵다.

이 내용을 바탕으로 다음을 가정해 보자. Form 이 있고 EmailInput이 있고 PasswordInput이 있다. 그럼 이 Email, Password Input에 대한 이벤트 핸들러는 어디서 정의해서 어떻게 사용해야 할까?

상태값이 어디에 의존적인지에 따라 다르다고 생각이 들었다. 상태값이 외부에 의존적이라면? 외부에서 전달해준다. 그렇지 않다면 내부에 선언한다.

어느정도 고민을 하며 가이드라인이 명시적이여 지는 느낌이 들어 이제 가이드라인을 작성해보려 한다.

## 리액트 클린코드 가이드라인

### 네이밍

#### 변수

- 명사로 정의한다.
- 불리언 값을 가지는 경우 `is`, `has` 와 같은 동사가 붙을 수 있다.

#### 함수

- 일반 함수
  - 동사로 시작한다.
- 이벤트 핸들러
  - handle~~ 의 형태로 작성한다.
  - 예) handleAccountInputChange 등

### 역할 분담

#### 컴포넌트 역할

View 와 Trigger의 역할을 한다. 상태값을 받아 그에 따른 UI를 보여주며 유저와 상호작용하며 이벤트를 호출한다. 컴포넌트 내부에는 최대한 어떤 비즈니스 로직도 적지 않는다. 이벤트 핸들러, 조건문 등만 기술될 수 있다.

#### 커스텀훅 역할

비즈니스 로직을 작성한다. 일반 함수와 다른점은 다른 훅을 사용해 비즈니스 로직을 처리해야 할 때 커스텀 훅의 형태로 작성된다.

#### 상태 = 데이터

리액트 쿼리, 클라이언트 상태 관리 도구 등을 통해 생성된 상태는 오로지 데이터로만 취급한다. 그 이상의 역할을 하도록 하지 않는다. 리액트 쿼리를 커스텀 훅으로 작성하더라도 그 내부에는 필요하지 않다면 어떠한 로직도 작성하지 않는다.
